# RAG-набор для игры «Подземелья Пёсики»

Этот архив — подготовленный датасет для построения RAG-поиска по книге правил настольной игры **«Подземелья Пёсики»**.

Цель набора — дать три понятных инструмента:

1. **Поиск по книге правил** (чанки правил).
2. **Поиск по термину** (глоссарий игровых понятий).
3. **Поиск по сущностям (NER)** — персонажи, монстры, квесты и т.п.  
   Фактически реализуется как часть того же глоссария (общая таблица терминов и сущностей).

---

## Структура архива

```text
rag_podzemelja_project/
├── README.md                    # этот файл
├── source/                      # исходные файлы
│   ├── podzemelja-i-pjosiki-act-rules.md
│   ├── podzemelja_chunks.jsonl
│   ├── terminology_database.json
│   ├── ner_database.json
│   └── README.md                # оригинальный README, если был
└── data/                        # подготовленные данные для RAG
    ├── podzemelja_chunks.cleaned.jsonl
    ├── terminology_flat.json
    ├── ner_flat.json
    └── terms_merged.json
```

### 1. `source/` — «сырые» данные

- **`podzemelja-i-pjosiki-act-rules.md`** — полный текст книги правил.
- **`podzemelja_chunks.jsonl`** — исходное автоматическое разбиение правил на чанки.  
  Формат: по одной JSON-строке на строку:
  ```json
  {"id": "setup_step_1",
   "content": "Каждый игрок выбирает себе пёсика...",
   "type": "instruction",
   "section": "setup"}
  ```
- **`terminology_database.json`** — иерархический глоссарий по компонентам игры, механикам, ресурсам и т.д.
- **`ner_database.json`** — NER-структура по персонажам, монстрам, квестам, символам, локациям.
- **`README.md`** — оригинальное описание набора (если было в исходных файлах).

---

## 2. Подготовленные данные в `data/`

### 2.1. `podzemelja_chunks.cleaned.jsonl`

Это улучшенное разбиение книги правил на чанки для RAG-поиска.

Отличия от исходного `podzemelja_chunks.jsonl`:

1. **Заголовки склеены с содержанием**, когда следующий чаник относится к той же `section`.

   Например, было:

   ```json
   {"id": "traps_title", "content": "ЛОВУШКИ", "type": "subsection_title", "section": "traps"}
   {"id": "trap_rules", "content": "Чтобы пройти ловушку, вы обязаны ...", "type": "instruction", "section": "traps"}
   ```

   Стало один чаник:

   ```json
   {
     "id": "trap_rules",
     "content": "ЛОВУШКИ\n\nЧтобы пройти ловушку, вы обязаны ...",
     "type": "instruction",
     "section": "traps",
     "merged_from": "traps_title",
     "isHeader": false
   }
   ```

2. Для всех чанков добавлен флаг:

   ```json
   "isHeader": true | false
   ```

   - `true` — чаник является чистым заголовком (и не был склеен с текстом).
   - `false` — нормальный содержательный чаник (или уже склеенный).

3. Чанки, у которых заголовок не имел собственного текста (например, `Эффекты комнат` без описания), **оставлены как отдельные записи**, но помечены `isHeader = true`.  
   В поиске по правилам их можно:
   - либо игнорировать (фильтр `isHeader == false`),
   - либо использовать только как вспомогательный контекст (например, для восстановления структуры раздела).

**Рекомендуемая модель в ObjectBox** для этого файла (`RuleChunk`):

- `id: String` — идентификатор чанка (`"trap_rules"`)
- `content: String` — текст чанка
- `section: String` — логический раздел (`"setup"`, `"monsters"`, `"traps"` и т.п.)
- `type: String` — тип чанка (`"rule"`, `"instruction"`, `"tip"`, `"narrative"`, `"section_title"` …)
- `isHeader: Boolean` — является ли чаник чистым заголовком
- `merged_from: String?` — id чанка-заголовка, если текущий был получен склейкой (опционально)
- (опционально) поля `prevId` / `nextId`, embedding и т.д. под нужды RAG.

Использование в RAG:

- **Поиск по книге правил** → ищем по эмбеддингам/ключевым словам именно среди чанков с `isHeader == false`, при необходимости подтягивая соседние чанки по `section`.

---

### 2.2. `terminology_flat.json`

Плоский глоссарий, полученный из `terminology_database.json`.

Каждая запись — это отдельный термин (игровой компонент, механика, ресурс и т.д.):

```json
{
  "id": "uuid",
  "name": "Room cards",
  "slug": "room_cards",
  "kind": "TERM",
  "path": "game_components/room_cards",
  "group": "game_components",
  "definition": "Карты, формирующие подземные лабиринты с монстрами и сокровищами",
  "extra": {
    "quantity": 90,
    "types": ["монстры", "монеты", "артефакты", "ловушки", "бродяги", "сундуки", "зелья", "двери", "порталы"]
  }
}
```

Поля:

- `id` — технический UUID термина.
- `name` — человекочитаемое имя (из ключа, но слегка очищено).
- `slug` — машинное имя (нижний регистр, подчёркивания вместо пробелов).
- `kind = "TERM"` — признак того, что это термин глоссария, а не сущность NER.
- `path` — полный путь в иерархии исходного файла (`"game_components/room_cards"`).
- `group` — верхнеуровневая группа (`"game_components"`, `"game_mechanics"`, `"resources"` …).
- `definition` — текстовое определение/описание термина.
- `extra` — словарь с дополнительными полями из исходного JSON (количество, типы и прочее).

Эта таблица подходит для инструмента **«поиск по термину»**, когда пользователь спрашивает, например:  
«Что такое комнатные карты?» / «Что означают жетоны лапок?»

---

### 2.3. `ner_flat.json`

Плоская таблица сущностей (NER), полученная из `ner_database.json`.

Каждая запись — персонаж, монстр, квест, символ или локация:

```json
{
  "id": "uuid",
  "name": "Робин Гудгёрл",
  "slug": "робин_гудгёрл",
  "kind": "ENTITY",
  "path": "player_characters",
  "group": "CHARACTER",
  "definition": "Следопыт. Перепрыгивает все ловушки",
  "extra": {
    "class": "Следопыт",
    "ability": "Перепрыгивает все ловушки",
    "first_mention": 77,
    "mentions": [77, 120]
  }
}
```

Поля:

- `kind = "ENTITY"` — признак сущности NER.
- `group` — тип сущности (`"CHARACTER"`, `"MONSTER"`, `"QUEST"`, `"SYMBOL"`, `"LOCATION"`, `"GAME_TITLE"` и т.д.).
- `definition` — краткое описание, собранное из полей (класс, способность, требования атаки, трофеи и т.п.).
- `extra` — все остальные поля исходной сущности (для более детальной логики на бэке).

Эта таблица нужна, чтобы реализовать поиск вида:

- «Что делает Плохиш Плуто?»
- «Как победить Шоколадного голема?»
- «Кто такой Мимик?»

---

### 2.4. `terms_merged.json`

Объединённая таблица **терминов и сущностей**, удобная как единый источник для инструмента «поиск по термину/NER».

Формат — просто конкатенация записей из `terminology_flat.json` и `ner_flat.json` в одном массиве.

- Записи с `kind = "TERM"` — обычные термины глоссария.
- Записи с `kind = "ENTITY"` — игровые сущности (персонажи, монстры, квесты и т.п.).

**Рекомендуемая модель в ObjectBox** (`Term`):

- `id: String`
- `name: String`
- `slug: String`
- `kind: String` — `"TERM"` или `"ENTITY"`
- `path: String`
- `group: String?`
- `definition: String`
- `extra: String` / JSON

Использование:

- Один инструмент **«поиск по термину»**, который:
  1. Ищет по `name`/`slug`/`definition` в `Term`.
  2. По `kind` понимает, это:
     - термин (`TERM`) → даём определение, можем дополнительно обновить запрос и искать чанки правил по этому термину,
     - сущность (`ENTITY`) → даём карточку персонажа/монстра/квеста и, при необходимости, подтягиваем релевантные чанки правил.

---

## 3. Как это использовать в RAG-пайплайне (концептуально)

### 3.1. Инструмент 1: поиск по книге правил

1. Пользователь задаёт вопрос:  
   «Как заканчивается игра и как считать монеты?»
2. Бэкенд:
   - делаем эмбеддинг вопроса;
   - ищем по эмбеддингам среди чанков из `podzemelja_chunks.cleaned.jsonl` с фильтром `isHeader == false`;
   - дополнительно бустим `section in ["game_end", "round_end", "coins_artifacts"]`.
3. В ответе:
   - краткое резюме человеческим языком;
   - 1–2 релевантных чанка как «цитаты» правил.

### 3.2. Инструмент 2: поиск по термину/NER

1. Пользователь:  
   «Что делает бродяга?» или «Кто такой Шоколадный голем?»
2. Бэкенд:
   - сначала ищет по `terms_merged.json` (таблица `Term`) по `name`/`slug`/`definition`;
   - находит запись:
     - `kind = "TERM"` (например, "бродяга") или
     - `kind = "ENTITY"` (например, конкретный персонаж/монстр);
   - возвращает:
     - краткое описание (`definition`),
     - при необходимости — далее использует `name`/`slug` как запрос к чанкам правил для дополнительного контекста.
3. Пользователь получает:
   - карточку термина/сущности;
   - при желании — ссылку на соответствующий фрагмент правил.

---

## 4. Где именно подключается ObjectBox

ObjectBox здесь выступает как удобное хранилище:

- Таблица `RuleChunk` ← данные из `podzemelja_chunks.cleaned.jsonl`.
- Таблица `Term` ← данные из `terms_merged.json`.

Дальше ты можешь:

- Строить **индекс для векторного поиска по `RuleChunk.content`**.
- Делать быстрый **строковый/BM25-поиск по `Term`** для глоссария и сущностей.
- Строить свои сервисы:
  - `/rules/search` — поиск по правилам (RAG).
  - `/terms/search` — поиск по терминам и NER.
  - и более высокоуровневый `/ask` — который комбинирует оба инструмента.

---

## 5. Что можно улучшать дальше

Этот архив даёт **готовый, структурированный слой данных**, поверх которого можно:

- добавить ручную разметку FAQ (популярные вопросы игроков → примеры для RAG),
- дообогатить `extra` у терминов/сущностей,
- ввести дополнительные поля типа `importance` или `isCoreRule`,
- сделать тонкую настройку retrieval (re-ranking, фильтры по разделам и типам чанков).

Но уже в текущем виде данные позволяют собрать качественный RAG-поиск по книге правил «Подземелья Пёсики» с отдельным глоссарием и поддержкой персонажей/монстров/квестов.
